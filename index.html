<html ><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252">

<script type="text/javascript" src="timelines.js"></script>
<script type="text/javascript" src="buildBackLinks.js"></script>
<script type="text/javascript" src="processTimelines.js"></script>
<script src="d3.js" charset="utf-8" type="text/javascript"></script>
<script src="d3.tip.v0.6.3.js" charset="utf-8" type="text/javascript"></script>

<link href="style.css" rel="stylesheet" type="text/css">

</head>


<body>
<div id="graph-container">
</div>
<script type="text/javascript">


buildBacklinks()
processTimelines()

if (timelines === null) {
    throw new Error("timelines are null")
}

// First, we specify the size of the canvas containing
// the visualization (size of the <div> element).

var width  = 800
var height = 600
var width  = window.innerWidth  - 30
var height = window.innerHeight - 50


// We create a color scale.
var color = d3.scale.category10();

// In the <div> element, we create a <svg> graphic
// that will contain our interactive visualization.
var svg = d3
    .select("#graph-container")
    .select("svg")

if (svg.empty()) {
    svg = d3.select("#graph-container").append("svg")
            .attr("width", width)
            .attr("height", height)

    background = svg.append("rect")
        .attr("width", "100%")
        .attr("height", "100%")
        .attr("fill", "#202020");
}

var panelID2nodeID = {}
var nodeID2panelID = {}
var nodes = []
var idCounter = 0



//  create nodes
panelIDs.forEach(function(panelID) {
    nodeID = idCounter
    idCounter += 1

    panelID2nodeID[panelID] = nodeID
    nodeID2panelID[nodeID] = panelID

    newNode = {
        id: nodeID,
        panelID: panelID,
        x: width * parseFloat(panelID - panelStart) / (panelEnd - panelStart)

    }
    nodes.push(newNode);
})

// get the -1.0 .. 1.0 offset for a link end
function getOffset(index, listLength) {
    if (listLength > 1) {
        return (index / (listLength-1.0)) - 0.5
    }
    else {
        return 0.0;
    }
}

// create link data
var links = []
panelIDs.forEach(function(panelID) {

    characters = timelines[panelID]
    numCharacters_source = characters.length
    var sourceCharacter = 0
    characters.forEach(function (character) {

        var colour = colours[character[1]]
        character[4].forEach(function (link) {
            targetPanelID = link[0]
            if (!(targetPanelID in panelID2nodeID)) {
                console.warn('target panel does not exist: ' + panelID)
                return;
            }

            targetCharacter = link[1]
            numCharacters_target = timelines[targetPanelID].length


            newEdge = {
                source: panelID2nodeID[panelID],
                target: panelID2nodeID[link[0]],
                colourID: character[1],
                sourceCharacter: sourceCharacter,
                targetCharacter: targetCharacter,
                offset1: getOffset(sourceCharacter, numCharacters_source),
                offset2: getOffset(targetCharacter, numCharacters_target),
            };
            links.push(newEdge);
        })

        // if (!isRequested(character)) {
        //     console.warn('character should have been filtered: ' + panelID)
        // }
        sourceCharacter += 1
    })

})






// We create a <line> SVG element for each link
var link = svg.selectAll(".link")
    .data(links)
    .enter()
    .append("path")
    .style("fill", "none")

    .style('stroke', function (d) { return colours[d.colourID] })


// We create a <circle> SVG element for each node
// in the graph, and we specify a few attributes.
var node = svg.selectAll(".node")
    .data(nodes)
    .enter().append("circle")
    .attr("class", "node")
    .attr("r", function(d){
        return 10;
    })  // radius
    // .style("fill", function(d) {
    //     // if (d.id == 6009) {
    //     //     return color(255);
    //     // }
    //     return color(0);
    // })
    // .on("click", function(d){
    //     console.log(d.panelID+': ' + JSON.stringify(timelines[d.panelID]))
    // });



function lerp(a, b, t) {
    return (1.0-t)*a + t*b
}

// We create a force-directed dynamic graph layout.
var force = d3.layout.force()
    .charge(-120)
    .linkDistance(50)
    .size([width, height])
    .nodes(nodes)
    .links(links)
    .start()
    .on("tick", function() {
        link.attr("d", function (d) {
            var x1 = d.source.x,
                y1 = d.source.y,
                x2 = d.target.x,
                y2 = d.target.y,
                dx = x2 - x1,
                dy = y2 - y1,
            // // Set dr to 0 for straight edges.
            // // Set dr to Math.sqrt(dx * dx + dy * dy) for a simple curve.
            // // Assuming a simple curve, decrease dr to space curves.
            // // There's probably a better decay function that spaces things nice and evenly.
            // dr = (
            //     Math.sqrt(dx * dx + dy * dy) -
            //     Math.sqrt(3000 * d.targetCharacter)
            // )
            // // dr = (d.targetCharacter+1) / 100;
            // // dr = 1/(d.targetCharacter+1);

            arrowLength = 10.0
            arrowWidth = 1.5
            linkBandWidth = 15.0

            x_source = x1
            y_source = y1
            x_target = x2
            y_target = y2

            vx = x_target - x_source
            vy = y_target - y_source
            lenV = Math.sqrt(vx*vx + vy*vy)
            vx /= lenV
            vy /= lenV

            x_target -= 10 * vx
            y_target -= 10 * vy


            // tangent
            tx = -vy
            ty =  vx

            x_source += linkBandWidth * d.offset1 * tx
            y_source += linkBandWidth * d.offset1 * ty
            x_target += linkBandWidth * d.offset2 * tx
            y_target += linkBandWidth * d.offset2 * ty

            vx = x_target - x_source
            vy = y_target - y_source
            lenV = Math.sqrt(vx*vx + vy*vy)
            vx /= lenV
            vy /= lenV
            tx = -vy
            ty =  vx


            // tx = -dy
            // ty =  dx
            // lenTangent = Math.sqrt(tx*tx + ty*ty)
            // tx /= lenTangent
            // ty /= lenTangent


            // x_target = lerp(x_source, x_target, 0.9)
            // y_target = lerp(y_source, y_target, 0.9)


            return (
                'M' +
                    x_source + ',' +
                    y_source +
                'L' +
                    x_target + ',' +
                    y_target
                +'L' +
                    (x_target - arrowLength*vx + arrowWidth*tx) + ',' +
                    (y_target - arrowLength*vy + arrowWidth*ty)
                +'L' +
                    (x_target - arrowLength*vx - arrowWidth*tx) + ',' +
                    (y_target - arrowLength*vy - arrowWidth*ty)
                +'L' +
                    x_target + ',' +
                    y_target
            )
        })

        node.attr("transform", function (d) {
            targetPos = parseFloat(d.panelID - panelStart) / (panelEnd - panelStart)
            targetPos *= width
            change = targetPos - d.x
            // change = change*2.0 - 1.0
            change *= 0.001
            // d.x += change
            return "translate(" + d.x + "," + d.y + ")"
        })

        // if (selectedNode != null) {
        //     // console.log(selectedNode)
        //     tip.show(selectedNode)
        // }

    })













// adds "The {0} grail".format('holy')
if (!String.prototype.format) {
  String.prototype.format = function() {
    var args = arguments;
    return this.replace(/{(\d+)}/g, function(match, number) {
      return typeof args[number] != 'undefined'
        ? args[number]
        : match
      ;
    });
  };
}

function pad(n, width, padChar) {
    padChar = padChar || '0';
    n = n + '';
    return n.length >= width ? n : new Array(width - n.length + 1).join(padChar) + n;
}

function makeURLfromPanelID(panelID) {
    return "http://mspaintadventures.com/?s=6&p=" + pad(panelID, 6)
}
var tip = d3.tip()
    .attr('class', 'd3-tip')
    .offset([-10, 0])
    .html(function(d) {
        if (!d) {
            return 'shits gone wrong'
        }

        html = ''

        containedPanelIDs[d.panelID].forEach(function (panelID) {
            html = html + '<a href="{0}" target="_blank">{1}</a> &nbsp; '.format(
                makeURLfromPanelID(panelID),
                panelID
                // linearSegments[d.panelID][1]
            )
        })
        return html
        // return JSON.stringify()
        // return '<a href="{0}" target="_blank"> {0} </a> <br/> {1}'.format(
        //     makeURLfromPanelID(d.panelID),
        //     linearSegments[d.panelID][1]
        // )
    })
    .hide()


var selectedNode = null;
function startTipTracking(d) {
    selectedNode = d
    tip.manualTarget = d3.event.target
    tip.show(d)
    // force.stop();

    if (!(d.fixed & 1)) {
        stopTipTracking()
    }
}

function stopTipTracking(d) {
    tip.hide(d)
    selectedNode = null
    tip.manualTarget = null
    // force.resume();
}


node
    // .on("click", stopTipTracking)
    .on("click", startTipTracking)
    // .on("dblclick", startTipTracking)

background
    .on("click", stopTipTracking)





function length(x, y) {
    return Math.sqrt(x*x + y*y)
}

force.drag()
    .on("dragstart", function (d) {
        stopTipTracking()
        d.dragstart_x = d.x
        d.dragstart_y = d.y
        d.startedFixed = (d.fixed & 1)? true : false;
        d3.select(this).classed("fixed", d.fixed = true)
    })
    .on("dragend", function (d) {
        dragDistance = length(
            d.dragstart_x - d.x,
            d.dragstart_y - d.y
        )

        fixed = dragDistance > 10 || !d.startedFixed

        if (d.x < 0 || d.x > width ) { fixed = false }
        if (d.y < 0 || d.y > height) { fixed = false }

        d3.select(this).classed("fixed", d.fixed = fixed)

        if (!fixed) {
            stopTipTracking()
            console.log('stahp')
        }
    })



svg.call(tip)

node.call(force.drag)

</script>
</body></html>
