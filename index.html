<html ><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252">

<script type="text/javascript" src="timelines.js"></script>
<script type="text/javascript" src="buildBackLinks.js"></script>
<script type="text/javascript" src="processTimelines.js"></script>
<script src="d3.js" charset="utf-8" type="text/javascript"></script>
<script src="d3.tip.v0.6.3.js" charset="utf-8" type="text/javascript"></script>

<link href="style.css" rel="stylesheet" type="text/css">

</head>


<body>


<div id="graph-container">
</div>



<script type="text/javascript">


buildBacklinks()
processTimelines()

if (timelines === null) {
    throw new Error("timelines are null")
}

// First, we specify the size of the canvas containing
// the visualization (size of the <div> element).
var width  = 800
var height = 600

// We create a color scale.
var color = d3.scale.category10();

// In the <div> element, we create a <svg> graphic
// that will contain our interactive visualization.
var svg = d3
    .select("#graph-container")
    .select("svg")

if (svg.empty()) {
    svg = d3.select("#graph-container").append("svg")
            .attr("width", width)
            .attr("height", height)

    svg.append("rect")
        .attr("width", "100%")
        .attr("height", "100%")
        .attr("fill", "#202020");
}

var panelID2nodeID = {}
var nodeID2panelID = {}
var nodes = []
var idCounter = 0



//  create nodes
panelIDs.forEach(function(panelID) {
    nodeID = idCounter
    idCounter += 1

    panelID2nodeID[panelID] = nodeID
    nodeID2panelID[nodeID] = panelID

    newNode = {
        id: nodeID,
        panelID: panelID,
        x: width * parseFloat(panelID - panelStart) / (panelEnd - panelStart)

    }
    nodes.push(newNode);
})

// get the -1.0 .. 1.0 offset for a link end
function getOffset(index, listLength) {
    if (listLength > 1) {
        return (index / (listLength-1.0)) - 0.5
    }
    else {
        return 0.0;
    }
}

// create link data
var links = []
panelIDs.forEach(function(panelID) {

    characters = timelines[panelID]
    numCharacters_source = characters.length
    var sourceCharacter = 0
    characters.forEach(function (character) {

        var colour = colours[character[1]]
        character[4].forEach(function (link) {
            targetPanelID = link[0]
            if (!(targetPanelID in panelID2nodeID)) {
                console.warn('target panel does not exist: ' + panelID)
                return;
            }

            targetCharacter = link[1]
            numCharacters_target = timelines[targetPanelID].length


            newEdge = {
                source: panelID2nodeID[panelID],
                target: panelID2nodeID[link[0]],
                colourID: character[1],
                sourceCharacter: sourceCharacter,
                targetCharacter: targetCharacter,
                offset1: getOffset(sourceCharacter, numCharacters_source),
                offset2: getOffset(targetCharacter, numCharacters_target),
            };
            links.push(newEdge);
        })

        // if (!isRequested(character)) {
        //     console.warn('character should have been filtered: ' + panelID)
        // }
        sourceCharacter += 1
    })

})






// We create a <line> SVG element for each link
var link = svg.selectAll(".link")
    .data(links)
    .enter()
    .append("path")
    .style("fill", "none")

    .style('stroke', function (d) { return colours[d.colourID] })


// We create a <circle> SVG element for each node
// in the graph, and we specify a few attributes.
var node = svg.selectAll(".node")
    .data(nodes)
    .enter().append("circle")
    .attr("class", "node")
    .attr("r", function(d){ return 10; })  // radius
    .style("fill", function(d) {
        // if (d.id == 6009) {
        //     return color(255);
        // }
        return color(0);
    })
    // .on("click", function(d){
    //     console.log(d.panelID+': ' + JSON.stringify(timelines[d.panelID]))
    // });



function lerp(a, b, t) {
    return (1.0-t)*a + t*b
}

// We create a force-directed dynamic graph layout.
var force = d3.layout.force()
    .charge(-120)
    .linkDistance(50)
    .size([width, height])
    .nodes(nodes)
    .links(links)
    .start()
    .on("tick", function() {
        link.attr("d", function (d) {
            var x1 = d.source.x,
                y1 = d.source.y,
                x2 = d.target.x,
                y2 = d.target.y,
                dx = x2 - x1,
                dy = y2 - y1,
            // // Set dr to 0 for straight edges.
            // // Set dr to Math.sqrt(dx * dx + dy * dy) for a simple curve.
            // // Assuming a simple curve, decrease dr to space curves.
            // // There's probably a better decay function that spaces things nice and evenly.
            // dr = (
            //     Math.sqrt(dx * dx + dy * dy) -
            //     Math.sqrt(3000 * d.targetCharacter)
            // )
            // // dr = (d.targetCharacter+1) / 100;
            // // dr = 1/(d.targetCharacter+1);

            // tangent
            tx = -dy
            ty =  dx
            lenTangent = Math.sqrt(tx*tx + ty*ty)
            tx /= lenTangent
            ty /= lenTangent

            x_source = (x1 + 18.0*d.offset1*tx)
            y_source = (y1 + 18.0*d.offset1*ty)
            x_target = (x2 + 18.0*d.offset2*tx)
            y_target = (y2 + 18.0*d.offset2*ty)


            x_target = lerp(x_source, x_target, 0.9)
            y_target = lerp(y_source, y_target, 0.9)

            arrowWidth = 1.5

            return (
                // 'M' + x1 + ',' + y1 +
                'M' +
                    x_source + ',' +
                    y_source +
                // "A" + (dr) + "," + (dr) + " 0 0,1 " + x2 + "," + y2
                // 'M' + (x1+5) + ',' + y1 +
                // 'L' + (x2+15.0) + ',' + y2
                'L' +
                    x_target + ',' +
                    y_target
                +'L' +
                    (lerp(x_source, x_target, 0.8) + arrowWidth*tx) + ',' +
                    (lerp(y_source, y_target, 0.8) + arrowWidth*ty)
                +'L' +
                    (lerp(x_source, x_target, 0.8) - arrowWidth*tx) + ',' +
                    (lerp(y_source, y_target, 0.8) - arrowWidth*ty)
                +'L' +
                    x_target + ',' +
                    y_target
                // "M{0},{1}".format(x1, y1) +
                // "L{0},{1}".format(x2-5, y2)
            )
        })

        node.attr("transform", function (d) {
            targetPos = parseFloat(d.panelID - panelStart) / (panelEnd - panelStart)
            targetPos *= width
            change = targetPos - d.x
            // change = change*2.0 - 1.0
            change *= 0.001
            d.x += change
            return "translate(" + d.x + "," + d.y + ")"
        })

        if (selectedNode != null) {
            // console.log(selectedNode)
            tip.show(selectedNode)
        }

    })













// adds "The {0} grail".format('holy')
if (!String.prototype.format) {
  String.prototype.format = function() {
    var args = arguments;
    return this.replace(/{(\d+)}/g, function(match, number) {
      return typeof args[number] != 'undefined'
        ? args[number]
        : match
      ;
    });
  };
}

function pad(n, width, padChar) {
    padChar = padChar || '0';
    n = n + '';
    return n.length >= width ? n : new Array(width - n.length + 1).join(padChar) + n;
}

function makeURLfromPanelID(panelID) {
    return "http://mspaintadventures.com/?s=6&p=" + pad(panelID, 6)
}
var tip = d3.tip()
    .attr('class', 'd3-tip')
    .offset([-10, 0])
    .html(function(d) {
        if (!d) {
            return 'shits gone wrong'
        }

        html = ''
        containedPanelIDs[d.panelID].forEach(function (panelID) {
            html = html + '<a href="{0}" target="_blank">{1}</a> &nbsp; '.format(
                makeURLfromPanelID(panelID),
                panelID
                // linearSegments[d.panelID][1]
            )
        })
        return html
        // return JSON.stringify()
        // return '<a href="{0}" target="_blank"> {0} </a> <br/> {1}'.format(
        //     makeURLfromPanelID(d.panelID),
        //     linearSegments[d.panelID][1]
        // )
    })


var selectedNode = null;
function startTipTracking(d) {
    selectedNode = d
    tip.manualTarget = d3.event.target
    tip.show(d)
    force.stop();
}

function stopTipTracking(d) {
    tip.hide(d)
    selectedNode = null
    tip.manualTarget = null
    force.resume();
}

node
    .on("click", stopTipTracking)
    .on("dblclick", startTipTracking)



svg.call(tip)

node.call(force.drag)

</script>

</body></html>
